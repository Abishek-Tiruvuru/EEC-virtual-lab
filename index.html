<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>All-in-One Circuit Lab – Web Simulator (with Graphics)</title>
<style>
  :root{
    --bg:#0f172a;       /* slate-900 */
    --panel:#111827;    /* gray-900 */
    --muted:#64748b;    /* slate-500 */
    --text:#e5e7eb;     /* gray-200 */
    --accent:#22c55e;   /* green-500 */
    --accent2:#3b82f6;  /* blue-500 */
    --danger:#ef4444;   /* red-500 */
    --card:#0b1222;     /* dark card */
  }
  html,body{height:100%}
  body{margin:0;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;
       background:linear-gradient(160deg, #0b1020 0%, #0f172a 50%, #0b1020 100%);
       color:var(--text);}  
  .app{display:grid;grid-template-columns:280px 1fr;min-height:100vh}
  .sidebar{position:sticky;top:0;align-self:start;max-height:100vh;overflow:auto;background:rgba(17,24,39,.8);backdrop-filter:saturate(120%) blur(8px);border-right:1px solid #1f2937;padding:14px 10px}
  .brand{display:flex;gap:10px;align-items:center;padding:10px 12px;margin-bottom:8px}
  .brand b{font-size:18px}
  .brand span{color:var(--muted);font-size:12px}
  .nav{display:flex;flex-direction:column;gap:6px}
  .nav button{all:unset;cursor:pointer;padding:10px 12px;border-radius:12px;color:var(--text);
    border:1px solid transparent;background:transparent;}
  .nav button.active{background:linear-gradient(180deg,#0d1b38,#0a1224);border-color:#1f2b46;box-shadow:0 0 0 1px #1f2b46 inset}
  .nav small{color:var(--muted)}
  .content{padding:18px 18px 60px}
  .panel{background:rgba(10,15,28,.7);border:1px solid #1f2b46;border-radius:16px;padding:16px;margin-bottom:18px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .row{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px}
  label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  input,select{width:100%;padding:10px 12px;border-radius:12px;border:1px solid #263453;background:#0a1224;color:var(--text)}
  .btn{all:unset;display:inline-block;padding:10px 14px;border-radius:12px;background:var(--accent2);color:white;cursor:pointer;font-weight:600}
  .btn.ghost{background:transparent;border:1px solid #2a437a}
  .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .kpi{background:var(--card);border:1px solid #17223e;border-radius:14px;padding:12px}
  .kpi h3{margin:.2rem 0 .5rem;font-size:14px;color:#94a3b8}
  .kpi b{font-size:22px}
  canvas{width:100%;height:280px;background:#0a0f1e;border:1px solid #1b2748;border-radius:12px}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid #1b2748;padding:8px;text-align:right}
  th:first-child,td:first-child{text-align:left}
  .note{color:#9ca3af;font-size:12px}
  .footer{opacity:.7;text-align:center;font-size:12px;margin-top:6px}
  .hidden{display:none}
  /* simple circuit styling */
  .ckt{background:#0a0f1e;border:1px solid #1b2748;border-radius:12px;padding:8px}
  .ckt svg{width:100%;height:auto}
  .wire{stroke:#5b729f;stroke-width:2;fill:none}
  .part{stroke:#e2e8f0;stroke-width:2;fill:none}
  .label{font:12px ui-sans-serif;fill:#cbd5e1}
  .value{font:12px ui-sans-serif;fill:#22c55e}
  .toolbar{display:flex;gap:8px;padding:0 0 10px 0}
  @media print{
    body{background:white;color:black}
    .sidebar{display:none}
    canvas{filter:grayscale(1)}
    .content{padding:0}
    .panel{page-break-inside:avoid;border:1px solid #ddd;background:white;color:black}
    .note{color:#333}
  }
</style>
</head>
<body>
<div class="app">
  <aside class="sidebar">
    <div class="brand">
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 2l2.6 5.3L20 8l-4 3.9.9 5.6L12 15.8 7.1 17.5 8 11.9 4 8l5.4-.7L12 2z" stroke="#3b82f6" fill="none" stroke-width="1.2"/>
      </svg>
      <div>
        <b>All‑in‑One Circuit Lab</b><br>
        <span>DC & Diode/BJT demos</span>
      </div>
    </div>
    <div class="toolbar">
      <button class="btn" id="btnPrint">Export PDF</button>
      <button class="btn ghost" id="btnReset">Reset</button>
    </div>
    <div class="nav" id="nav"></div>
    <div class="footer">Tip: tweak sliders to see diagram values update</div>
  </aside>
  <main class="content">
    <div id="mount"></div>
  <div style="text-align:center;margin-top:20px;font-size:12px;opacity:.7;">Made by Abishek</div>
  </main>
</div>

<script>
/*********************** UTILITIES *************************/
const $ = (sel, el=document) => el.querySelector(sel);
const el = (tag, cls, html) => {const e=document.createElement(tag); if(cls) e.className=cls; if(html!=null) e.innerHTML=html; return e};
const fmt = (x, d=4) => Number(x).toFixed(d).replace(/\.0+$/,'').replace(/(\.\d*[1-9])0+$/,'$1');
function line(ctx, x1,y1,x2,y2){ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();}
function plot(canvas, xs, ys, {xlabel="", ylabel="", y2=null}={}){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  const pl=40, pr=12, pt=10, pb=28;
  const xmin = Math.min(...xs), xmax = Math.max(...xs);
  const ymin = Math.min(...ys, ...(y2||[Infinity]));
  const ymax = Math.max(...ys, ...(y2||[-Infinity]));
  const nx = (x)=> pl + (x-xmin)/(xmax-xmin||1) * (W-pl-pr);
  const ny = (y)=> H-pb - (y-ymin)/(ymax-ymin||1) * (H-pt-pb);
  const grid = '#223058';
  const axis = '#425b99';
  const series = ['#3b82f6','#22c55e'];
  ctx.lineWidth=1; ctx.strokeStyle=grid;
  for(let i=0;i<=5;i++){ const gx = pl + i*(W-pl-pr)/5; line(ctx,gx,pt,gx,H-pb); }
  for(let i=0;i<=5;i++){ const gy = pt + i*(H-pt-pb)/5; line(ctx,pl,gy,W-pr,gy); }
  ctx.strokeStyle=axis; line(ctx,pl,pt,pl,H-pb); line(ctx,pl,H-pb,W-pr,H-pb);
  ctx.fillStyle="#94a3b8"; ctx.font="12px ui-sans-serif";
  ctx.fillText(xlabel, W/2-20, H-8); ctx.save(); ctx.rotate(-Math.PI/2); ctx.fillText(ylabel,-H/2-20,14); ctx.restore();
  ctx.strokeStyle=series[0]; ctx.lineWidth=2; ctx.beginPath();
  xs.forEach((x,i)=>{ const X=nx(x), Y=ny(ys[i]); i?ctx.lineTo(X,Y):ctx.moveTo(X,Y) }); ctx.stroke();
  if(y2){ ctx.strokeStyle=series[1]; ctx.beginPath(); xs.forEach((x,i)=>{ const X=nx(x), Y=ny(y2[i]); i?ctx.lineTo(X,Y):ctx.moveTo(X,Y) }); ctx.stroke(); }
}
function setText(id, value){ const n=document.getElementById(id); if(n) n.textContent=value; }
function setAttr(id, attr, value){ const n=document.getElementById(id); if(n) n.setAttribute(attr, value); }

function addKPIs(container, items){
  const grid = el('div','row');
  items.forEach(({label,value,unit,id})=>{
    const box = el('div','kpi');
    box.innerHTML = `<h3>${label}</h3><b id="${id}">${value}</b> <span>${unit||''}</span>`;
    grid.appendChild(box);
  });
  container.appendChild(grid);
}
function numberInput(name, val, unit="", step="any"){
  const wrap = el('div');
  wrap.innerHTML = `<label>${name}${unit?` (${unit})`:''}</label><input type="number" step="${step}" value="${val}"/>`;
  return wrap;
}
function sliderInput(name, val, min, max, unit=""){
  const wrap = el('div');
  wrap.innerHTML = `<label>${name}: <b class="val">${fmt(val)}</b> ${unit}</label><input type="range" min="${min}" max="${max}" step="any" value="${val}">`;
  const rng = $('input', wrap), v=$('.val', wrap);
  rng.addEventListener('input',()=>{v.textContent = fmt(rng.value); wrap.dispatchEvent(new CustomEvent('change'))});
  return wrap;
}
/********************** APP SHELL **************************/
const experiments = [
  {id:'kvl', name:'Exp1 – KVL (Series Resistive)'},
  {id:'kcl', name:'Exp2 – KCL (Node to Ground)'},
  {id:'mesh', name:'Exp3 – Mesh Analysis (2‑loop)'},
  {id:'th', name:'Exp4 – Thevenin Equivalent'},
  {id:'norton', name:'Exp5 – Norton Equivalent'},
  {id:'super', name:'Exp6 – Superposition (2 sources)'},
  {id:'maxp', name:'Exp7 – Maximum Power Transfer'},
  {id:'recip', name:'Exp8 – Reciprocity (simple 2‑port)'},
  {id:'subs', name:'Exp9 – Substitution Theorem'},
  {id:'diode', name:'Exp10 – Diode I–V'},
  {id:'zener', name:'Exp11 – Zener Diode (Fwd/Rev)'},
  {id:'hwr', name:'Exp12 – Half‑Wave Rectifier'},
  {id:'bjt', name:'Exp13 – BJT Characteristics'}
];
let nav, mount, current = null;

function select(id, btn){
  [...nav.children].forEach(b=>b.classList.remove('active')); if(btn) btn.classList.add('active');
  current=id; mount.innerHTML='';
  const fn = panels[id]; if(fn) fn(mount);
}

/********************** SVG PARTS **************************/
function svgBattery(x,y,idp){
  return `<g transform="translate(${x},${y})">
    <line class="part" x1="0" y1="0" x2="0" y2="40"/>
    <line class="part" x1="8" y1="-8" x2="8" y2="48"/>
    <text class="label" x="14" y="-6">Vs</text>
    <text id="${idp}_Vs" class="value" x="14" y="10">12 V</text>
  </g>`;
}
function svgResistor(x,y,len,id,label){
  const z = `<polyline class="part" points="0,0 10,0 15,-8 25,8 35,-8 45,8 55,-8 65,8 75,-8 85,8 90,0 ${len},0"/>`;
  return `<g transform="translate(${x},${y})">${z}<text class="label" x="${len/2-18}" y="-16">${label}</text><text id="${id}" class="value" x="${len/2-22}" y="-2">100 Ω</text></g>`;
}
function svgGround(x,y){
  return `<g transform="translate(${x},${y})"><line class="part" x1="0" y1="0" x2="0" y2="10"/><line class="part" x1="-12" y1="10" x2="12" y2="10"/><line class="part" x1="-8" y1="14" x2="8" y2="14"/><line class="part" x1="-4" y1="18" x2="4" y2="18"/></g>`;
}

/********************** PANELS *****************************/
const panels = {};

/* Exp1 – KVL */
panels.kvl = (root)=>{
  const p = el('div','panel');
  p.innerHTML = `<h2>Exp1 – Kirchhoff's Voltage Law (Series R)</h2><p class="note">ΣV around a closed loop equals 0. Series chain: Vsrc = V1+V2+V3 and I = Vsrc/(R1+R2+R3).</p>`;
  const form = el('div','row');
  const V = sliderInput('Source V', 12, 0, 24, 'V');
  const R1 = sliderInput('R1', 100, 1, 1000, 'Ω');
  const R2 = sliderInput('R2', 220, 1, 1000, 'Ω');
  const R3 = sliderInput('R3', 330, 1, 1000, 'Ω');
  [V,R1,R2,R3].forEach(w=> form.appendChild(w));
  p.appendChild(form);

  const c = el('div','ckt');
  c.innerHTML = `<svg viewBox="0 0 720 220" xmlns="http://www.w3.org/2000/svg">
    <rect x="1" y="1" width="718" height="218" rx="10" ry="10" fill="none" stroke="#1b2748"/>
    ${svgBattery(80,60,'kvlsvg')}
    <path class="wire" d="M88,60 h120"/>
    ${svgResistor(208,60,120,'kvl_R1','R1')}
    <path class="wire" d="M328,60 h40"/>
    ${svgResistor(368,60,120,'kvl_R2','R2')}
    <path class="wire" d="M488,60 h40"/>
    ${svgResistor(528,60,120,'kvl_R3','R3')}
    <path class="wire" d="M648,60 v100 h-560 v-100"/>
    <text class="label" x="320" y="120">Loop current I</text>
    <text id="kvl_I_read" class="value" x="420" y="120">— A</text>
  </svg>`;
  p.appendChild(c);

  addKPIs(p,[
    {label:'Loop Current', value:'—', unit:'A', id:'kvl_I'},
    {label:'Drop R1', value:'—', unit:'V', id:'kvl_V1'},
    {label:'Drop R2', value:'—', unit:'V', id:'kvl_V2'},
    {label:'Drop R3', value:'—', unit:'V', id:'kvl_V3'},
    {label:'Check Vsrc − Σdrops', value:'—', unit:'V', id:'kvl_chk'}
  ]);
  function calc(){
    const v=+$('input',V).value, r1=+$('input',R1).value, r2=+$('input',R2).value, r3=+$('input',R3).value;
    const Rt = r1+r2+r3; const I = v/(Rt||1e-12);
    const v1=I*r1, v2=I*r2, v3=I*r3; const chk = v-(v1+v2+v3);
    setText('kvl_I', fmt(I,6)); setText('kvl_V1', fmt(v1)); setText('kvl_V2', fmt(v2)); setText('kvl_V3', fmt(v3)); setText('kvl_chk', fmt(chk,6));
    setText('kvl_I_read', `${fmt(I,6)} A`);
    setText('kvl_R1', `${fmt(r1)} Ω`); setText('kvl_R2', `${fmt(r2)} Ω`); setText('kvl_R3', `${fmt(r3)} Ω`);
    setText('kvlsvg_Vs', `${fmt(v)} V`);
  }
  p.addEventListener('input',calc); root.appendChild(p); calc();
}

/* Exp2 – KCL */
panels.kcl = (root)=>{
  const p = el('div','panel');
  p.innerHTML = `<h2>Exp2 – Kirchhoff's Current Law (Node)</h2><p class="note">At a node, currents leaving equal currents entering. Node at V<sub>n</sub> with three branches to ground.</p>`;
  const form = el('div','row');
  const Vn = sliderInput('Node voltage', 10, 0, 20, 'V');
  const R1 = sliderInput('R1', 100, 1, 2000, 'Ω');
  const R2 = sliderInput('R2', 200, 1, 2000, 'Ω');
  const R3 = sliderInput('R3', 300, 1, 2000, 'Ω');
  ;[Vn,R1,R2,R3].forEach(x=>form.appendChild(x)); p.appendChild(form);

  const c = el('div','ckt');
  c.innerHTML = `<svg viewBox="0 0 720 220" xmlns="http://www.w3.org/2000/svg">
    <rect x="1" y="1" width="718" height="218" rx="10" ry="10" fill="none" stroke="#1b2748"/>
    <circle cx="360" cy="80" r="4" fill="#e2e8f0"/>
    <text class="label" x="372" y="84">Vn</text>
    <text id="kcl_Vn" class="value" x="400" y="84">10 V</text>
    <path class="wire" d="M360,80 v20"/>
    ${svgResistor(320,100,80,'kcl_R1','R1')}<path class="wire" d="M400,100 v40"/>${svgGround(400,140)}
    ${svgResistor(200,80,120,'kcl_R2','R2')}<path class="wire" d="M200,80 v80"/>${svgGround(200,160)}
    ${svgResistor(440,80,120,'kcl_R3','R3')}<path class="wire" d="M560,80 v80"/>${svgGround(560,160)}
    <text class="label" x="40" y="200">Currents: I = Vn/R</text>
    <text id="kcl_i_read" class="value" x="220" y="200">—</text>
  </svg>`;
  p.appendChild(c);

  addKPIs(p,[{label:'I1',value:'—',unit:'A',id:'kcl_i1'},{label:'I2',value:'—',unit:'A',id:'kcl_i2'},{label:'I3',value:'—',unit:'A',id:'kcl_i3'},{label:'ΣI (leaving)',value:'—',unit:'A',id:'kcl_sum'}]);
  function calc(){
    const v=+$('input',Vn).value, r1=+$('input',R1).value, r2=+$('input',R2).value, r3=+$('input',R3).value;
    const i1=v/(r1||1e-12), i2=v/(r2||1e-12), i3=v/(r3||1e-12); const s=i1+i2+i3;
    setText('kcl_i1', fmt(i1,6)); setText('kcl_i2', fmt(i2,6)); setText('kcl_i3', fmt(i3,6)); setText('kcl_sum', fmt(s,6));
    setText('kcl_Vn', `${fmt(v)} V`); setText('kcl_R1', `${fmt(r1)} Ω`); setText('kcl_R2', `${fmt(r2)} Ω`); setText('kcl_R3', `${fmt(r3)} Ω`);
    setText('kcl_i_read', `I1=${fmt(i1,6)} A, I2=${fmt(i2,6)} A, I3=${fmt(i3,6)} A`);
  }
  p.addEventListener('input',calc); root.appendChild(p); calc();
}

/* Exp3 – Mesh (2‑loop resistive) */
panels.mesh = (root)=>{
  const p = el('div','panel');
  p.innerHTML = `<h2>Exp3 – Mesh Analysis (2‑loop)</h2><p class="note">Two meshes share R3. Equations: (R1+R3)I1 − R3 I2 = V1; −R3 I1 + (R2+R3)I2 = V2.</p>`;
  const form=el('div','row');
  const V1 = numberInput('V1 (left source)', 10, 'V');
  const V2 = numberInput('V2 (right source)', 0, 'V');
  const R1 = numberInput('R1 (left)', 100, 'Ω');
  const R2 = numberInput('R2 (right)', 150, 'Ω');
  const R3 = numberInput('R3 (shared)', 50, 'Ω');
  ;[V1,V2,R1,R2,R3].forEach(x=>form.appendChild(x)); p.appendChild(form);
  addKPIs(p,[{label:'Mesh I1',value:'—',unit:'A',id:'m_i1'},{label:'Mesh I2',value:'—',unit:'A',id:'m_i2'}]);
  function calc(){
    const v1=+$('input',V1).value, v2=+$('input',V2).value, r1=+$('input',R1).value, r2=+$('input',R2).value, r3=+$('input',R3).value;
    const a=r1+r3, b=-r3, c=-r3, d=r2+r3; const det=a*d-b*c || 1e-12;
    const i1=(v1*d - b*v2)/det; const i2=(a*v2 - v1*c)/det;
    setText('m_i1', fmt(i1,6)); setText('m_i2', fmt(i2,6));
  }
  p.addEventListener('input',calc); root.appendChild(p); calc();
}

/* Exp4 – Thevenin */
panels.th = (root)=>{
  const p = el('div','panel');
  p.innerHTML = `<h2>Exp4 – Thevenin Equivalent</h2><p class="note">A source seen by the load is V<sub>Th</sub> with series R<sub>Th</sub>. For load R<sub>L</sub>: I = Vth/(Rth+RL), Vout = I·RL.</p>`;
  const form=el('div','row');
  const Vth=sliderInput('Vth',12,0,30,'V'); const Rth=sliderInput('Rth',1000,1,20000,'Ω'); const RL=sliderInput('Load RL',4700,1,20000,'Ω');
  ;[Vth,Rth,RL].forEach(x=>form.appendChild(x)); p.appendChild(form);

  const c = el('div','ckt');
  c.innerHTML = `<svg viewBox="0 0 720 220" xmlns="http://www.w3.org/2000/svg">
    <rect x="1" y="1" width="718" height="218" rx="10" ry="10" fill="none" stroke="#1b2748"/>
    ${svgBattery(80,80,'thsvg')}
    <path class="wire" d="M88,80 h120"/>
    ${svgResistor(208,80,140,'th_Rth','Rth')}
    <path class="wire" d="M348,80 h120"/>
    ${svgResistor(468,80,120,'th_RL','RL')}
    <path class="wire" d="M588,80 v80 h-500 v-80"/>
    ${svgGround(588,160)}
    <text class="label" x="468" y="70">Vout</text>
    <text id="th_V_read" class="value" x="510" y="70">— V</text>
  </svg>`;
  p.appendChild(c);

  addKPIs(p,[{label:'Load Current',value:'—',unit:'A',id:'th_I'},{label:'Load Voltage',value:'—',unit:'V',id:'th_V'},{label:'Load Power',value:'—',unit:'W',id:'th_P'}]);
  function calc(){
    const v=+$('input',Vth).value,r=+$('input',Rth).value,rl=+$('input',RL).value; const I=v/((r+rl)||1e-12); const V=I*rl; const P=I*I*rl;
    setText('th_I', fmt(I,6)); setText('th_V', fmt(V)); setText('th_P', fmt(P));
    setText('thsvg_Vs', `${fmt(v)} V`); setText('th_Rth', `${fmt(r)} Ω`); setText('th_RL', `${fmt(rl)} Ω`); setText('th_V_read', `${fmt(V)} V`);
  }
  p.addEventListener('input',calc); root.appendChild(p); calc();
}

/* Exp5 – Norton */
panels.norton = (root)=>{
  const p = el('div','panel');
  p.innerHTML = `<h2>Exp5 – Norton Equivalent</h2><p class="note">Equivalent current source I<sub>N</sub> in parallel with R<sub>N</sub>. With load R<sub>L</sub>: Vout = IN·(RN || RL)·(RL/(RN+RL)).</p>`;
  const form=el('div','row');
  const IN=numberInput('IN',0.012,'A'); const RN=numberInput('RN',1000,'Ω'); const RL=numberInput('Load RL',4700,'Ω');
  ;[IN,RN,RL].forEach(x=>form.appendChild(x)); p.appendChild(form);
  addKPIs(p,[{label:'Load Voltage',value:'—',unit:'V',id:'no_V'},{label:'Load Current',value:'—',unit:'A',id:'no_I'}]);
  function calc(){
    const inr=+$('input',IN).value, rn=+$('input',RN).value, rl=+$('input',RL).value; const v = inr*(rn*rl/(rn+rl||1e-12)); const i = v/(rl||1e-12);
    setText('no_V', fmt(v)); setText('no_I', fmt(i,6));
  }
  p.addEventListener('input',calc); root.appendChild(p); calc();
}

/* Exp6 – Superposition */
panels.super = (root)=>{
  const p = el('div','panel');
  p.innerHTML = `<h2>Exp6 – Superposition</h2><p class="note">Two sources drive a single node through R1, R2 to ground via RL. Node V = V1·(G1/(G1+G2+GL)) + V2·(G2/(G1+G2+GL)).</p>`;
  const form=el('div','row');
  const V1=numberInput('V1',10,'V'); const R1=numberInput('R1',1000,'Ω'); const V2=numberInput('V2',10,'V'); const R2=numberInput('R2',1000,'Ω'); const RL=numberInput('RL',1000,'Ω');
  ;[V1,R1,V2,R2,RL].forEach(x=>form.appendChild(x)); p.appendChild(form);
  addKPIs(p,[{label:'Node Voltage',value:'—',unit:'V',id:'sp_v'},{label:'Contribution of V1',value:'—',unit:'V',id:'sp_v1'},{label:'Contribution of V2',value:'—',unit:'V',id:'sp_v2'}]);
  function calc(){
    const v1=+$('input',V1).value, r1=+$('input',R1).value, v2=+$('input',V2).value, r2=+$('input',R2).value, rl=+$('input',RL).value;
    const g1=1/(r1||1e-12), g2=1/(r2||1e-12), gl=1/(rl||1e-12), G=g1+g2+gl;
    const v1c=v1*(g1/G), v2c=v2*(g2/G), v=v1c+v2c;
    setText('sp_v', fmt(v)); setText('sp_v1', fmt(v1c)); setText('sp_v2', fmt(v2c));
  }
  p.addEventListener('input',calc); root.appendChild(p); calc();
}

/* Exp7 – Maximum Power Transfer */
panels.maxp = (root)=>{
  const p = el('div','panel');
  p.innerHTML = `<h2>Exp7 – Maximum Power Transfer</h2><p class="note">For a Thevenin source, load power is maximized when RL = Rth.</p>`;
  const form = el('div','row');
  const Vth = numberInput('Vth', 12, 'V'); const Rth = numberInput('Rth', 100, 'Ω'); const RL = sliderInput('RL', 100, 1, 500, 'Ω');
  ;[Vth,Rth,RL].forEach(x=>form.appendChild(x)); p.appendChild(form);
  const canv = el('canvas'); canv.width=900; canv.height=320; p.appendChild(canv);
  addKPIs(p,[{label:'RL* for max P',value:'—',unit:'Ω',id:'mp_rl'},{label:'Pmax',value:'—',unit:'W',id:'mp_p'}]);
  function calc(){
    const v=+$('input',Vth).value, r=+$('input',Rth).value, rl=+$('input',RL).value;
    const xs=[], ys=[]; for(let R=1; R<=500; R+=2){ const I=v/(r+R); ys.push(I*I*R); xs.push(R); }
    plot(canv,xs,ys,{xlabel:'RL (Ω)',ylabel:'Load Power (W)'});
    const pmax = (v*v)/(4*r||1e-12); setText('mp_rl', fmt(r)); setText('mp_p', fmt(pmax));
  }
  p.addEventListener('input',calc); root.appendChild(p); calc();
}

/* Exp8 – Reciprocity (simple) */
panels.recip = (root)=>{
  const p = el('div','panel');
  p.innerHTML = `<h2>Exp8 – Reciprocity</h2><p class="note">For a linear bilateral network, transfer current/voltage is unchanged when source and detector are interchanged. Here: a T‑network (R1‑R3‑R2). We compare current through Rd when source is at left vs right.</p>`;
  const form=el('div','row');
  const R1=numberInput('R1',1000,'Ω'); const R2=numberInput('R2',1000,'Ω'); const R3=numberInput('R3 (shunt middle)',1000,'Ω'); const Rd=numberInput('Detector Rd',1000,'Ω'); const Vs=numberInput('Source Vs',10,'V');
  ;[R1,R2,R3,Rd,Vs].forEach(x=>form.appendChild(x)); p.appendChild(form);
  addKPIs(p,[{label:'Id (source left)',value:'—',unit:'A',id:'rc_l'},{label:'Id (source right)',value:'—',unit:'A',id:'rc_r'}]);
  function netCurrent(sourceLeft){
    const r1=+$('input',R1).value, r2=+$('input',R2).value, r3=+$('input',R3).value, rd=+$('input',Rd).value, v=+$('input',Vs).value;
    const side = sourceLeft ? {Ra:r1,Rb:r2} : {Ra:r2,Rb:r1};
    const Rseries = side.Ra; const Rafter = side.Rb;
    const RtoG = 1 / (1/r3 + 1/(Rafter+rd));
    const Vnode = v * (RtoG / (Rseries + RtoG));
    return Vnode / (Rafter + rd);
  }
  function calc(){ const left=netCurrent(true), right=netCurrent(false); setText('rc_l', fmt(left,6)); setText('rc_r', fmt(right,6)); }
  p.addEventListener('input',calc); root.appendChild(p); calc();
}

/* Exp9 – Substitution Theorem (wired to your sheet values) */
panels.subs = (root)=>{
  const p = el('div','panel');
  p.innerHTML = `<h2>Exp9 – Substitution Theorem</h2>
  <p class="note">Topology matches your sheet: Va → R220 → node X. From X to ground: R100a. From X to node Y: Rx (the substituted element). From Y to ground: R47. Step‑1: measure current through Rx (I1) and the drop Vxy. Step‑2: replace Rx with an ideal source of Vxy and measure I2. For a linear resistive network, I1 ≈ I2. (Ref: your lab PDF). </p>`;

  const form=el('div','row');
  const Va = sliderInput('Va (source)',10,0,30,'V');
  const R220 = numberInput('R220 (series)',220,'Ω');
  const R100a = numberInput('R100a (shunt at X)',100,'Ω');
  const Rx = numberInput('Rx (to be substituted)',100,'Ω');
  const R47 = numberInput('R47 (to ground at Y)',47,'Ω');
  ;[Va,R220,R100a,Rx,R47].forEach(x=>form.appendChild(x)); p.appendChild(form);

  const c = el('div','ckt');
  c.innerHTML = `<svg viewBox="0 0 760 240" xmlns="http://www.w3.org/2000/svg">
    <rect x="1" y="1" width="758" height="238" rx="10" ry="10" fill="none" stroke="#1b2748"/>
    ${svgBattery(60,60,'subsVs')}
    <path class="wire" d="M68,60 h100"/>
    ${svgResistor(168,60,140,'subs_R220','220Ω')}
    <path class="wire" d="M308,60 h40"/>
    <circle cx="348" cy="60" r="4" fill="#e2e8f0"/>
    <text class="label" x="336" y="44">X</text>
    ${svgResistor(308,80,80,'subs_R100a','100Ω')}
    <path class="wire" d="M388,80 v60"/>${svgGround(388,140)}
    <path class="wire" d="M348,60 h120"/>
    ${svgResistor(468,60,120,'subs_Rx','Rx')}
    <path class="wire" d="M588,60 v0"/>
    <circle cx="588" cy="60" r="4" fill="#e2e8f0"/>
    <text class="label" x="580" y="44">Y</text>
    <path class="wire" d="M588,60 v60"/>
    ${svgResistor(588,120,80,'subs_R47','47Ω')}
    <path class="wire" d="M588,200 h-480 v-140"/>
    ${svgGround(588,200)}
    <text class="label" x="430" y="44">Vxy</text>
    <text id="subs_Vxy" class="value" x="430" y="30">— V</text>
  </svg>`;
  p.appendChild(c);

  addKPIs(p,[
    {label:'I1 through Rx (orig)',value:'—',unit:'A',id:'sub_i1'},
    {label:'Vxy across Rx',value:'—',unit:'V',id:'sub_vxy'},
    {label:'I2 with Vxy source',value:'—',unit:'A',id:'sub_i2'},
    {label:'|I1−I2| / I1',value:'—',unit:'',id:'sub_err'}
  ]);

  function solveOriginal(){
    const VaV=+$('input',Va).value, Rser=+$('input',R220).value, Rsh=+$('input',R100a).value, Rxv=+$('input',Rx).value, Rg=+$('input',R47).value;
    // Unknowns: Vx, Vy. Equations via KCL at X and Y. Source is ideal VaV in series with Rser.
    // At node X: (Vx - VaV)/Rser + Vx/Rsh + (Vx - Vy)/Rxv = 0
    // At node Y: (Vy - Vx)/Rxv + Vy/Rg = 0
    const a11 = (1/Rser)+(1/Rsh)+(1/Rxv);
    const a12 = (-1/Rxv);
    const b1  = (VaV/Rser);
    const a21 = (-1/Rxv);
    const a22 = (1/Rxv)+(1/Rg);
    const b2  = 0;
    const det = a11*a22 - a12*a21 || 1e-18;
    const Vx = (b1*a22 - a12*b2)/det;
    const Vy = (a11*b2 - b1*a21)/det;
    const I1 = (Vx - Vy)/Rxv; // current through Rx (from X to Y)
    const Vxy = Vx - Vy;
    return {Vx,Vy,I1,Vxy};
  }
  function solveSubstituted(Vxy){
    const VaV=+$('input',Va).value, Rser=+$('input',R220).value, Rsh=+$('input',R100a).value, Rg=+$('input',R47).value;
    // Replace Rx with ideal voltage source: Vx - Vy = Vxy. Unknowns: Vx, Vy.
    // KCL at X: (Vx - VaV)/Rser + Vx/Rsh + (Vx - Vy)/Rvs = 0 but Rvs=0 (ideal). Handle via constraint Vx - Vy = Vxy and KCLs without the (Vx-Vy)/0 term.
    // Approach: Express Vy = Vx - Vxy. KCL at X and Y using only resistors to ground/series.
    const Vy_expr = (Vx)=> Vx - Vxy;
    // KCL at X considering only paths: to source resistor, to shunt Rsh, to the ideal source (no resistive current). We still need one more equation: KCL at Y with path to ground only.
    // Use two equations:
    // (1) (Vx - VaV)/Rser + Vx/Rsh + Ivs = 0
    // (2) Vy/Rg - Ivs = 0  (current through source into node Y equals current to ground), and Vy = Vx - Vxy
    // Eliminate Ivs: From (2) Ivs = Vy/Rg. Plug into (1): (Vx - VaV)/Rser + Vx/Rsh + Vy/Rg = 0.
    // Substitute Vy = Vx - Vxy.
    const A = (1/Rser) + (1/Rsh) + (1/Rg);
    const B = (VaV/Rser) + (Vxy/Rg);
    const Vx = B / A;
    const Vy = Vx - Vxy;
    const I2 = Vy / Rg; // equals Ivs, current through ideal source into node Y (same branch current)
    return {Vx,Vy,I2};
  }

  function calc(){
    const orig = solveOriginal();
    const sub = solveSubstituted(orig.Vxy);
    setText('sub_i1', fmt(orig.I1,6));
    setText('sub_vxy', fmt(orig.Vxy));
    setText('sub_i2', fmt(sub.I2,6));
    const err = Math.abs(orig.I1 - sub.I2) / (Math.abs(orig.I1)||1e-12);
    setText('sub_err', fmt(err,6));
    setText('subs_R220', `${fmt(+$('input',R220).value)} Ω`);
    setText('subs_R100a', `${fmt(+$('input',R100a).value)} Ω`);
    setText('subs_Rx', `${fmt(+$('input',Rx).value)} Ω`);
    setText('subs_R47', `${fmt(+$('input',R47).value)} Ω`);
    setText('subsVs_Vs', `${fmt(+$('input',Va).value)} V`);
    setText('subs_Vxy', `${fmt(orig.Vxy)} V`);
  }
  p.addEventListener('input',calc); root.appendChild(p); calc();
}

/* Exp10 – Diode I‑V */
panels.diode = (root)=>{
  const p = el('div','panel'); p.innerHTML = `<h2>Exp10 – Diode Characteristics</h2><p class="note">Shockley: I = Is( e^{Vd/(n·Vt)} − 1 ). Assume T=300K ⇒ Vt≈25.85 mV.</p>`;
  const form=el('div','row');
  const Is=numberInput('Is',1e-12,'A'); const n=numberInput('n (ideality)',1.9,'');
  ;[Is,n].forEach(x=>form.appendChild(x)); p.appendChild(form);
  const canv=el('canvas'); canv.width=900; canv.height=320; p.appendChild(canv);
  const table=el('div','panel'); table.innerHTML='<h3>Sample Points</h3><table><thead><tr><th>Vd (V)</th><th>I (A)</th></tr></thead><tbody id="dtab"></tbody></table>';
  root.appendChild(p); root.appendChild(table);
  function calc(){
    const IS=+$('input',Is).value, N=+$('input',n).value; const Vt=0.02585; const xs=[], ys=[]; const tbody=document.getElementById('dtab'); if(tbody) tbody.innerHTML='';
    for(let v=-0.4; v<=0.9; v+=0.02){ const i = IS*(Math.exp(v/(N*Vt)) - 1); xs.push(v); ys.push(i); if(tbody && Math.abs((v*100)%10)<1e-9){ const tr=el('tr','',`<td>${fmt(v,3)}</td><td>${i>0?fmt(i,6):fmt(i,3)}</td>`); tbody.appendChild(tr);} }
    const ydraw = ys.map(y=> Math.sign(y)*Math.log10(Math.abs(y)+1));
    plot(canv,xs,ydraw,{xlabel:'Vd',ylabel:'log10(|I|+1)'});
  }
  p.addEventListener('input',calc); calc();
}

/* Exp11 – Zener (forward & reverse) */
panels.zener = (root)=>{
  const p = el('div','panel');
  p.innerHTML = `<h2>Exp11 – Zener Diode Characteristics</h2>
  <p class="note">Forward and Reverse (breakdown) modes with clean circuit icons. Sliders update readings and the sweep plot.</p>`;

  const form=el('div','row');
  const modeWrap = el('div');
  modeWrap.innerHTML = `<label>Mode</label>
    <select id="zn_mode">
      <option value="fwd">Forward Bias</option>
      <option value="rev">Reverse (Breakdown)</option>
    </select>`;
  const Vs = sliderInput('Supply Vs', 0, 0, 30, 'V');
  const Rs = sliderInput('Series Rs', 1000, 1, 10000, 'Ω');
  const Is = numberInput('Diode Is',1e-12,'A');
  const n  = numberInput('n (ideality)',1.9,'');
  const Vz = numberInput('Vz (breakdown)',5.1,'V');
  const rz = numberInput('rz (dyn.)',10,'Ω');
  [modeWrap,Vs,Rs,Is,n,Vz,rz].forEach(x=>form.appendChild(x)); p.appendChild(form);

  const c = el('div','ckt');
  c.innerHTML = `<svg viewBox="0 0 720 220" xmlns="http://www.w3.org/2000/svg">
    <rect x="1" y="1" width="718" height="218" rx="10" ry="10" fill="none" stroke="#1b2748"/>
    ${svgBattery(80,80,'znsvg')}
    <path class="wire" d="M88,80 h120"/>
    ${svgResistor(208,80,140,'zn_Rs','Rs')}
    <path class="wire" d="M348,80 h120"/>
    <g transform="translate(468,80)">
      <polygon class="part" points="0,-10 0,10 20,0"/>
      <line class="part" x1="20" y1="-12" x2="20" y2="12"/>
      <text class="label" x="-6" y="-20">D</text>
      <text id="zn_Dv" class="value" x="-10" y="28">— V</text>
    </g>
    <path class="wire" d="M488,80 h100"/>
    <path class="wire" d="M588,80 v80 h-500 v-80"/>
    ${svgGround(588,160)}
    <text class="label" x="300" y="140">Id</text>
    <text id="zn_Id" class="value" x="330" y="140">— A</text>
  </svg>`;
  p.appendChild(c);

  addKPIs(p,[
    {label:'Diode Voltage (Vd)',value:'—',unit:'V',id:'zn_vd'},
    {label:'Diode Current (Id)',value:'—',unit:'A',id:'zn_id'},
    {label:'Static R (|Vd/Id|)',value:'—',unit:'Ω',id:'zn_rs'},
    {label:'Dynamic R (ΔV/ΔI)',value:'—',unit:'Ω',id:'zn_rd'}
  ]);

  const canv=el('canvas'); canv.width=900; canv.height=320; p.appendChild(canv);

  function diodeForwardCurrent(vd, IS, N){ const Vt=0.02585; return IS*(Math.exp(vd/(N*Vt)) - 1); }
  function solveForward(vs, rs, IS, N){
    let vd=0.7; for(let k=0;k<40;k++){ const id=diodeForwardCurrent(vd,IS,N); const f = id*rs + vd - vs; const diddvd=(id+IS)/(N*0.02585); const df = diddvd*rs + 1; vd -= f/df; if(Math.abs(f)<1e-9) break; }
    const id = Math.max(0, diodeForwardCurrent(vd,IS,N)); return {vd,id};
  }
  function solveReverse(vs, rs, vz, rdz){
    const iz = Math.max(0, (vs - vz) / (rs + rdz)); const vd = Math.min(vs, vz + rdz*iz);
    return {vd:vd, id:iz};
  }

  function calc(){
    const mode = document.getElementById('zn_mode').value;
    const vs=+$('input',Vs).value, rs=+$('input',Rs).value, IS=+$('input',Is).value, N=+$('input',n).value, vz=+$('input',Vz).value, rdz=+$('input',rz).value;
    let vd=0, id=0; let rd='—';
    if(mode==='fwd'){ const r=solveForward(vs,rs,IS,N); vd=r.vd; id=r.id; const Vt=0.02585; const diddvd=(diodeForwardCurrent(vd,IS,N)+IS)/(N*Vt); rd = fmt(1/diddvd,4);
    } else { const r=solveReverse(vs,rs,vz,rdz); vd=r.vd; id=r.id; rd = fmt(rdz,4); }
    setText('zn_vd', fmt(vd)); setText('zn_id', fmt(id,6)); setText('zn_rs', id?fmt(Math.abs(vd/id)):'∞'); setText('zn_rd', rd);
    setText('zn_Rs', `${fmt(rs)} Ω`); setText('zn_Dv', `${fmt(vd)} V`); setText('zn_Id', `${fmt(id,6)} A`); setText('znsvg_Vs', `${fmt(vs)} V`);

    const xs=[], ys=[]; const Vmin = 0, Vmax = 30; const step = 0.2;
    for(let sv=Vmin; sv<=Vmax; sv+=step){ let cur=0; if(mode==='fwd'){ cur=solveForward(sv,rs,IS,N).id; } else { cur=solveReverse(sv,rs,vz,rdz).id; } xs.push(sv); ys.push(cur); }
    plot(canv,xs,ys,{xlabel:'Vs (V)',ylabel:'Id (A)'});
  }
  p.addEventListener('input',calc); root.appendChild(p); calc();
}

/* Exp12 – Half‑Wave Rectifier (Transformer + optional filter) */
panels.hwr = (root)=>{
  const p = el('div','panel'); p.innerHTML = `<h2>Exp12 – Half‑Wave Rectifier</h2><p class="note">50 Hz transformer secondary, diode drop, optional capacitor filter across RL. Clean icons.</p>`;
  const form=el('div','row');
  const Vrms=sliderInput('Transformer Secondary (Vrms)',6,1,20,'V');
  const f=numberInput('Frequency',50,'Hz');
  const drop=numberInput('Diode drop',0.6,'V');
  const RL=numberInput('Load RL',1000,'Ω');
  const Cwrap=el('div'); Cwrap.innerHTML=`<label>Filter capacitor</label>
      <select id="hwr_filter">
        <option value="off">Without filter</option>
        <option value="on">With filter</option>
      </select>`;
  const Cap=sliderInput('C (filter)',100e-6,1e-6,1000e-6,'F');
  ;[Vrms,f,drop,RL,Cwrap,Cap].forEach(x=>form.appendChild(x)); p.appendChild(form);

  const c = el('div','ckt');
  c.innerHTML = `<svg viewBox="0 0 720 160" xmlns="http://www.w3.org/2000/svg">
    <rect x="1" y="1" width="718" height="158" rx="10" ry="10" fill="none" stroke="#1b2748"/>
    <rect x="60" y="40" width="60" height="40" class="part" fill="none"/>
    <text class="label" x="65" y="35">Tr (Vrms)</text>
    <text id="hwr_vr" class="value" x="65" y="95">6 V</text>
    <path class="wire" d="M120,60 h60"/>
    <g transform="translate(180,60)">
      <polygon class="part" points="0,-10 0,10 20,0"/>
      <line class="part" x1="20" y1="-12" x2="20" y2="12"/>
      <text class="label" x="-6" y="-20">D</text>
    </g>
    <path class="wire" d="M200,60 h80"/>
    ${svgResistor(280,60,120,'hwr_RL','RL')}
    <path class="wire" d="M400,60 v60"/>
    <g transform="translate(440,60)">
      <line class="part" x1="0" y1="-12" x2="0" y2="12"/>
      <line class="part" x1="8" y1="-12" x2="8" y2="12"/>
      <text class="label" x="-10" y="-20">C</text>
      <text id="hwr_C" class="value" x="-10" y="28">100 µF</text>
    </g>
    <path class="wire" d="M448,60 v60"/>
    <path class="wire" d="M120,120 h328"/>
    ${svgGround(448,120)}
  </svg>`;
  p.appendChild(c);

  const canv=el('canvas'); canv.width=900; canv.height=320; p.appendChild(canv);
  addKPIs(p,[{label:'V_DC',value:'—',unit:'V',id:'hw_vdc'},{label:'V_RMS',value:'—',unit:'V',id:'hw_vrms'},{label:'Ripple factor r',value:'—',unit:'',id:'hw_r'}]);

  function simulate(){
    const Vr=+$('input',Vrms).value, F=+$('input',f).value, Vd=+$('input',drop).value, rl=+$('input',RL).value, C=+$('input',Cap).value;
    const filter = document.getElementById('hwr_filter').value==='on';
    const w=2*Math.PI*F; const Vm = Math.SQRT2*Vr; const T=1/F; const N=1600;
    const xs=[], yout=[]; let vC=0; // capacitor voltage
    for(let i=0;i<=N;i++){
      const t=i/N*4*T; // simulate 4 periods
      const vin = Vm*Math.sin(w*t);
      let vrect = vin>Vd ? (vin-Vd) : 0;
      if(!filter){ yout.push(vrect); xs.push(t); }
      else {
        if(vrect>vC){ vC = vrect; } else { const dt = (i>0? (4*T)/N : 0); vC *= Math.exp(-dt/(rl*C)); }
        yout.push(vC); xs.push(t);
      }
    }
    plot(canv,xs,yout,{xlabel:'time (s)',ylabel:'Vout'});
    const start = Math.floor(N*0.5); const seg = yout.slice(start);
    const vdc = seg.reduce((a,b)=>a+b,0)/seg.length;
    const vrms = Math.sqrt(seg.reduce((a,b)=>a+b*b,0)/seg.length);
    const r = Math.sqrt(Math.max(vrms*vrms - vdc*vdc,0))/(vdc||1e-12);
    setText('hw_vdc', fmt(vdc)); setText('hw_vrms', fmt(vrms)); setText('hw_r', fmt(r));
    setText('hwr_vr', `${fmt(Vr)} V`); setText('hwr_RL', `${fmt(rl)} Ω`); setText('hwr_C', `${C>=1e-6?fmt(C*1e6):fmt(C*1e9)} ${C>=1e-6?'µF':'nF'}`);
  }
  p.addEventListener('input',simulate); root.appendChild(p); simulate();
}

/* Exp13 – BJT CE Input & Output (BC107) */
panels.bjt = (root)=>{
  const p = el('div','panel'); p.innerHTML = `<h2>Exp13 – BJT CE Characteristics (BC107)</h2><p class="note">Input (IB–VBE at VCE≈0V & 5V) and Output (IC–VCE for IB=0, 20µA, 40µA). Clean icons; simple model with β and VCE(sat).</p>`;
  const form=el('div','row');
  const Beta=numberInput('β (DC gain)',100,'');
  const Vsat=numberInput('VCE(sat)',0.2,'V');
  const Is=numberInput('Is (BE)',1e-14,'A');
  const n =numberInput('n (BE)',1.9,'');
  const modeWrap=el('div'); modeWrap.innerHTML=`<label>Mode</label>
    <select id="bjt_mode">
      <option value="in">Input (IB–VBE)</option>
      <option value="out">Output (IC–VCE)</option>
    </select>`;
  ;[modeWrap,Beta,Vsat,Is,n].forEach(x=>form.appendChild(x)); p.appendChild(form);

  const canv=el('canvas'); canv.width=900; canv.height=320; p.appendChild(canv);
  addKPIs(p,[{label:'Note',value:'—',unit:'',id:'bj_note'}]);

  function ib_from_vbe(vbe, IS, N){ const Vt=0.02585; return Math.max(0, IS*(Math.exp(vbe/(N*Vt))-1)); }
  function drawThirdSeries(canvas, xs, baseYs, ys){
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const pl=40, pr=12, pt=10, pb=28;
    const xmin = Math.min(...xs), xmax = Math.max(...xs);
    const ymin = Math.min(...baseYs), ymax = Math.max(...baseYs);
    const nx = (x)=> pl + (x-xmin)/(xmax-xmin||1) * (W-pl-pr);
    const ny = (y)=> H-pb - (y-ymin)/(ymax-ymin||1) * (H-pt-pb);
    ctx.strokeStyle = '#ef4444'; ctx.lineWidth=2; ctx.beginPath();
    xs.forEach((x,i)=>{ const X=nx(x), Y=ny(ys[i]); i?ctx.lineTo(X,Y):ctx.moveTo(X,Y); });
    ctx.stroke();
  }

  function simulate(){
    const B=+$('input',Beta).value, VCEsat=+$('input',Vsat).value, IS=+$('input',Is).value, N=+$('input',n).value;
    const mode = document.getElementById('bjt_mode').value;
    if(mode==='in'){
      const xs=[], i0=[], i5=[]; for(let v=0; v<=0.9; v+=0.01){ xs.push(v); i0.push(ib_from_vbe(v,IS,N)); i5.push(ib_from_vbe(v,IS,N)); }
      plot(canv,xs,i0,{xlabel:'VBE (V)',ylabel:'IB (A)', y2:i5});
      setText('bj_note','Approx. same curve for VCE≈0V and 5V (Early effect ignored).');
    } else {
      const xs=[], ibs=[0,20e-6,40e-6], fam=[[],[],[]]; const VCC=12; const RC=1000;
      for(let v=0; v<=12; v+=12/200){ xs.push(v); ibs.forEach((ib,idx)=>{ const ic=B*ib; const ic_sat=Math.max(0,(VCC - v - VCEsat)/RC); const I=Math.max(0,Math.min(ic,ic_sat)); fam[idx].push(I); }); }
      plot(canv,xs,fam[0],{xlabel:'VCE (V)',ylabel:'IC (A)', y2:fam[1]});
      drawThirdSeries(canv, xs, fam[0].concat(fam[1]), fam[2]);
      setText('bj_note','Curves for IB = 0, 20µA, 40µA; RC = 1 kΩ, VCC = 12 V; saturation clipped.');
    }
  }
  p.addEventListener('input',simulate); root.appendChild(p); simulate();
}

/********************** INIT & SMOKE TEST ******************/
function smokeTest(){
  try{
    const orig = current;
    experiments.forEach((ex, idx)=>{ select(ex.id, nav.children[idx]); });
    if(orig){ const idx = experiments.findIndex(e=>e.id===orig); select(orig, nav.children[idx]); } else select(experiments[0].id, nav.children[0]);
    console.log('%cSmoke test passed: panels mount & calc without nulls','color:#22c55e');
  }catch(e){ console.error('Smoke test failed', e); }
}

window.addEventListener('DOMContentLoaded', ()=>{
  nav = document.getElementById('nav');
  mount = document.getElementById('mount');
  experiments.forEach((x,i)=>{
    const b=el('button', i? '' : 'active', `<div>${x.name}<br><small class="note">${x.id.toUpperCase()}</small></div>`);
    b.onclick=()=>select(x.id,b);
    nav.appendChild(b);
  });
  select(experiments[0].id, nav.children[0]);
  smokeTest();
  $('#btnPrint').addEventListener('click', ()=>window.print());
  $('#btnReset').addEventListener('click', ()=>{ location.reload(); });
});
</script>
</body>
</html>
